# -*- coding: utf-8 -*-
"""keras-CNN.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1koVOhOXd_SoKTxgSWq_OgtDzSnnOKGpx

# CNN Keras

## Introduction

We build a Sequentital Convolutional Neural Network for digits recognition. The network has 5 layers and is trained on the MNIST dataset. We build this CNN using the Keras API.

Note: for computational reasons, the epochs is set to 2. If you wish to achieve 99%+ accuracy, set epochs to 30.
"""

# Commented out IPython magic to ensure Python compatibility.
# Loading required libraries
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import matplotlib.image as mpimg
import seaborn as sns
# %matplotlib inline

RAND_SEED = 2
np.random.seed(2)

from sklearn.model_selection import train_test_split
from sklearn.metrics import confusion_matrix
import itertools

from keras.models import Sequential
from keras.layers import Dense, Dropout, Flatten, Conv2D, MaxPool2D
from keras.optimizers import RMSprop
from keras.preprocessing.image import ImageDataGenerator
from keras.callbacks import ReduceLROnPlateau
from keras.utils.np_utils import to_categorical # for one-hot-encoding

from google.colab import drive
drive.mount("/drive")

"""## Data Preparation"""

# Loading datasets
train, test = pd.read_csv("/drive/My Drive/input/train.csv"), pd.read_csv("/drive/My Drive/input/test.csv")

y_train = train["label"]

X_train = train.drop(labels = ["label"], axis = 1)

g = sns.countplot(y_train)
y_train.value_counts()

"""### Checking Null / Missing Values

We check for corrupted images (images that contain missing values within). As a result there is no missing values in datasets `train` and `test`.
"""

# Check train null/missing values
X_train.isnull().any().describe()

test.isnull().any().describe()

"""### Normalization

We perform a grayscale normalization to reduce the effect of illumination's differences, such that the CNN achieves faster convergence. Note that the CNN converges faster on [0..1] than on [0..255].
"""

# Normalize data
X_train /= 255.0
test /= 255.0

# Reshape images to vectors
X_train, test = X_train.values.reshape(-1, 28, 28, 1), test.values.reshape(-1, 28, 28, 1)

"""### Label Encoding
The original images were labeled with digits (e.g. image 8 is labeled with '8'). We encode them to one-hot vectors. For instance, image 8 is labeled as vector [0, 0, 0, 0, 0, 0, 0, 0, 1, 0].
"""

y_train = to_categorical(y_train, num_classes = 10)

"""### Splitting Training Set for Validation

"""

X_train, X_val, y_train, y_val = train_test_split(X_train, y_train, test_size = 0.1, random_state = RAND_SEED)

"""### Some Samples from Data"""

plt.imshow(X_train[6][:,:,0])

"""## CNN
### Defining the Model
"""

# Initialize the CNN Model
# Model Architechture: 2 * [2 * [Conv2D -> relu] -> MaxPool2D -> Dropout] -> Flatten -> Dense -> Dropout -> Output]
model = Sequential()

########################################################################
# First 2 * [Conv2D -> relu] -> MaxPool2D -> Dropout

# 2 * Conv2D -> Relu Layers
model.add(Conv2D(filters = 32, kernel_size = (5, 5), padding = "Same", activation = "relu", input_shape = (28, 28, 1)))
model.add(Conv2D(filters = 32, kernel_size = (5, 5), padding = "Same", activation = "relu", input_shape = (28, 28, 1)))

# MaxPool 2D Layer
model.add(MaxPool2D(pool_size = (2, 2)))

# Dropout Layer
model.add(Dropout(0.25))

########################################################################
# Second 2 * [Conv2D -> relu] -> MaxPool2D -> Dropout

# 2 * Conv2D -> Relu Layers
model.add(Conv2D(filters = 64, kernel_size = (3, 3), padding = "Same", activation = "relu", input_shape = (28, 28, 1)))
model.add(Conv2D(filters = 64, kernel_size = (3, 3), padding = "Same", activation = "relu", input_shape = (28, 28, 1)))

# MaxPool 2D Layer
model.add(MaxPool2D(pool_size = (2, 2), strides = (2, 2)))

# Dropout Layer
model.add(Dropout(0.25))
########################################################################

# Flatten Layer
model.add(Flatten())

# Dense Layer
model.add(Dense(256, activation = "relu"))

# Dropout Layer
model.add(Dropout(.5))

# Output Softmax
model.add(Dense(10, activation = "softmax"))

# Defining the optimizer
optimizer = RMSprop(learning_rate = .001, rho = .9, epsilon = 1e-8, decay = 0.0)

# Copiling the model
model.compile(optimizer = optimizer, loss = "categorical_crossentropy", metrics = ["accuracy"])

# Setting a learning rate annealer
learning_rate_reduction = ReduceLROnPlateau(monitor = "val_accuracy",
                                            patience = 3,
                                            verbose = 1,
                                            factor = .5,
                                            min_lr = .00001)

# Change epoches to 30 to get .9967 accurary
epochs = 30 
batch_size = 86

"""## Augmenting Data"""

datagen = ImageDataGenerator(featurewise_center = False,
                             samplewise_center = False,      # set each sample mean to 0
                             featurewise_std_normalization = False,
                             samplewise_std_normalization = False,
                             zca_whitening = False,
                             rotation_range = 10,
                             zoom_range = .1,
                             width_shift_range = .1,
                             horizontal_flip = False,
                             vertical_flip = False)

datagen.fit(X_train)

# Fit the model
history = model.fit(datagen.flow(X_train, y_train, batch_size = batch_size),
                    epochs = epochs,
                    validation_data = (X_val, y_val),
                    verbose = 2, steps_per_epoch = X_train.shape[0] // batch_size,
                    callbacks = [learning_rate_reduction])

# Saving model
model.save("/drive/My Drive/keras-cnn-model")

"""## Model Evaluation"""

# Plot loss curves and accuracy curves for training/val
fig, ax = plt.subplots(2,1)
ax[0].plot(history.history["loss"], color = 'b', label = "Training loss")
ax[0].plot(history.history["val_loss"], color = 'r', label = "validation loss", axes = ax[0])
legend = ax[0].legend(loc = 'best', shadow = True)

ax[1].plot(history.history["accuracy"], color ='b', label = "Training accuracy")
ax[1].plot(history.history["val_accuracy"], color= 'r',label = "Validation accuracy")
legend = ax[1].legend(loc = "best", shadow = True)

# Predict results8
results = model.predict(test)
results = np.argmax(results, axis = 1)
results = pd.Series(results, name = "Label")

submission = pd.concat([pd.Series(range(1, 28001), name = "ImageId"), results], axis = 1)
submission.to_csv("/drive/My Drive/cnn_mnist_datagen-30-epochs.csv", index = False)